<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · NLPModels.jl</title><meta name="title" content="Reference · NLPModels.jl"/><meta property="og:title" content="Reference · NLPModels.jl"/><meta property="twitter:title" content="Reference · NLPModels.jl"/><meta name="description" content="Documentation for NLPModels.jl."/><meta property="og:description" content="Documentation for NLPModels.jl."/><meta property="twitter:description" content="Documentation for NLPModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NLPModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../batch_api/">Batch API</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#NLPModels.AbstractBatchNLPModel"><code>NLPModels.AbstractBatchNLPModel</code></a></li><li><a href="#NLPModels.AbstractBatchNLPModelMeta"><code>NLPModels.AbstractBatchNLPModelMeta</code></a></li><li><a href="#NLPModels.AbstractNLPModel"><code>NLPModels.AbstractNLPModel</code></a></li><li><a href="#NLPModels.AbstractNLPModelMeta"><code>NLPModels.AbstractNLPModelMeta</code></a></li><li><a href="#NLPModels.AbstractNLSModel"><code>NLPModels.AbstractNLSModel</code></a></li><li><a href="#NLPModels.BatchNLPModelMeta"><code>NLPModels.BatchNLPModelMeta</code></a></li><li><a href="#NLPModels.Counters"><code>NLPModels.Counters</code></a></li><li><a href="#NLPModels.DimensionError"><code>NLPModels.DimensionError</code></a></li><li><a href="#NLPModels.NLPModelMeta"><code>NLPModels.NLPModelMeta</code></a></li><li><a href="#NLPModels.NLSCounters"><code>NLPModels.NLSCounters</code></a></li><li><a href="#NLPModels.NLSMeta"><code>NLPModels.NLSMeta</code></a></li><li><a href="#Base.eltype-Union{Tuple{AbstractNLPModel{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>Base.eltype</code></a></li><li><a href="#LinearOperators.reset!-Tuple{Counters}"><code>LinearOperators.reset!</code></a></li><li><a href="#LinearOperators.reset!-Tuple{AbstractNLPModel}"><code>LinearOperators.reset!</code></a></li><li><a href="#NLPModels.bound_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.bound_constrained</code></a></li><li><a href="#NLPModels.cons-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.cons</code></a></li><li><a href="#NLPModels.cons!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.cons!</code></a></li><li><a href="#NLPModels.cons_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.cons_lin</code></a></li><li><a href="#NLPModels.cons_lin!"><code>NLPModels.cons_lin!</code></a></li><li><a href="#NLPModels.cons_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.cons_nln</code></a></li><li><a href="#NLPModels.cons_nln!"><code>NLPModels.cons_nln!</code></a></li><li><a href="#NLPModels.conscale"><code>NLPModels.conscale</code></a></li><li><a href="#NLPModels.coo_prod!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.coo_prod!</code></a></li><li><a href="#NLPModels.coo_sym_prod!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.coo_sym_prod!</code></a></li><li><a href="#NLPModels.decrement!-Tuple{AbstractNLPModel, Symbol}"><code>NLPModels.decrement!</code></a></li><li><a href="#NLPModels.equality_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.equality_constrained</code></a></li><li><a href="#NLPModels.get_constraint_bounds_analysis-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_constraint_bounds_analysis</code></a></li><li><a href="#NLPModels.get_grad_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_grad_available</code></a></li><li><a href="#NLPModels.get_hess_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_hess_available</code></a></li><li><a href="#NLPModels.get_hess_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_hess_residual_available</code></a></li><li><a href="#NLPModels.get_hprod_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_hprod_available</code></a></li><li><a href="#NLPModels.get_hprod_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_hprod_residual_available</code></a></li><li><a href="#NLPModels.get_ifix-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ifix</code></a></li><li><a href="#NLPModels.get_ifree-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ifree</code></a></li><li><a href="#NLPModels.get_iinf-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_iinf</code></a></li><li><a href="#NLPModels.get_ilow-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ilow</code></a></li><li><a href="#NLPModels.get_irng-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_irng</code></a></li><li><a href="#NLPModels.get_islp-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_islp</code></a></li><li><a href="#NLPModels.get_iupp-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_iupp</code></a></li><li><a href="#NLPModels.get_jac_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jac_available</code></a></li><li><a href="#NLPModels.get_jac_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_jac_residual_available</code></a></li><li><a href="#NLPModels.get_jfix-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jfix</code></a></li><li><a href="#NLPModels.get_jfree-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jfree</code></a></li><li><a href="#NLPModels.get_jinf-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jinf</code></a></li><li><a href="#NLPModels.get_jlow-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jlow</code></a></li><li><a href="#NLPModels.get_jprod_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jprod_available</code></a></li><li><a href="#NLPModels.get_jprod_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_jprod_residual_available</code></a></li><li><a href="#NLPModels.get_jrng-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jrng</code></a></li><li><a href="#NLPModels.get_jtprod_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jtprod_available</code></a></li><li><a href="#NLPModels.get_jtprod_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_jtprod_residual_available</code></a></li><li><a href="#NLPModels.get_jupp-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jupp</code></a></li><li><a href="#NLPModels.get_lcon-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lcon</code></a></li><li><a href="#NLPModels.get_lin-Tuple{NLSMeta}"><code>NLPModels.get_lin</code></a></li><li><a href="#NLPModels.get_lin-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lin</code></a></li><li><a href="#NLPModels.get_lin_nnzj-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lin_nnzj</code></a></li><li><a href="#NLPModels.get_lvar-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lvar</code></a></li><li><a href="#NLPModels.get_minimize-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_minimize</code></a></li><li><a href="#NLPModels.get_name-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_name</code></a></li><li><a href="#NLPModels.get_ncon-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ncon</code></a></li><li><a href="#NLPModels.get_nequ-Tuple{NLSMeta}"><code>NLPModels.get_nequ</code></a></li><li><a href="#NLPModels.get_nlin-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlin</code></a></li><li><a href="#NLPModels.get_nlin-Tuple{NLSMeta}"><code>NLPModels.get_nlin</code></a></li><li><a href="#NLPModels.get_nln-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nln</code></a></li><li><a href="#NLPModels.get_nln-Tuple{NLSMeta}"><code>NLPModels.get_nln</code></a></li><li><a href="#NLPModels.get_nln_nnzj-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nln_nnzj</code></a></li><li><a href="#NLPModels.get_nlvb-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlvb</code></a></li><li><a href="#NLPModels.get_nlvc-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlvc</code></a></li><li><a href="#NLPModels.get_nlvo-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlvo</code></a></li><li><a href="#NLPModels.get_nnln-Tuple{NLSMeta}"><code>NLPModels.get_nnln</code></a></li><li><a href="#NLPModels.get_nnln-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnln</code></a></li><li><a href="#NLPModels.get_nnzh-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnzh</code></a></li><li><a href="#NLPModels.get_nnzh-Tuple{NLSMeta}"><code>NLPModels.get_nnzh</code></a></li><li><a href="#NLPModels.get_nnzj-Tuple{NLSMeta}"><code>NLPModels.get_nnzj</code></a></li><li><a href="#NLPModels.get_nnzj-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnzj</code></a></li><li><a href="#NLPModels.get_nnzo-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnzo</code></a></li><li><a href="#NLPModels.get_nvar-Tuple{NLSMeta}"><code>NLPModels.get_nvar</code></a></li><li><a href="#NLPModels.get_nvar-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nvar</code></a></li><li><a href="#NLPModels.get_sparse_hessian-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_sparse_hessian</code></a></li><li><a href="#NLPModels.get_sparse_jacobian-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_sparse_jacobian</code></a></li><li><a href="#NLPModels.get_ucon-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ucon</code></a></li><li><a href="#NLPModels.get_uvar-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_uvar</code></a></li><li><a href="#NLPModels.get_variable_bounds_analysis-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_variable_bounds_analysis</code></a></li><li><a href="#NLPModels.get_x0-Tuple{NLSMeta}"><code>NLPModels.get_x0</code></a></li><li><a href="#NLPModels.get_x0-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_x0</code></a></li><li><a href="#NLPModels.get_y0-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_y0</code></a></li><li><a href="#NLPModels.ghjvprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.ghjvprod</code></a></li><li><a href="#NLPModels.ghjvprod!"><code>NLPModels.ghjvprod!</code></a></li><li><a href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.grad</code></a></li><li><a href="#NLPModels.grad!"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.grad!-Tuple{AbstractNLSModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.has_bounds-Tuple{AbstractNLPModelMeta}"><code>NLPModels.has_bounds</code></a></li><li><a href="#NLPModels.has_equalities-Tuple{AbstractNLPModelMeta}"><code>NLPModels.has_equalities</code></a></li><li><a href="#NLPModels.has_inequalities-Tuple{AbstractNLPModelMeta}"><code>NLPModels.has_inequalities</code></a></li><li><a href="#NLPModels.hess-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess</code></a></li><li><a href="#NLPModels.hess-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.hess</code></a></li><li><a href="#NLPModels.hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord</code></a></li><li><a href="#NLPModels.hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord</code></a></li><li><a href="#NLPModels.hess_coord!"><code>NLPModels.hess_coord!</code></a></li><li><a href="#NLPModels.hess_coord!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord!</code></a></li><li><a href="#NLPModels.hess_coord_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord_residual</code></a></li><li><a href="#NLPModels.hess_coord_residual!"><code>NLPModels.hess_coord_residual!</code></a></li><li><a href="#NLPModels.hess_dense!"><code>NLPModels.hess_dense!</code></a></li><li><a href="#NLPModels.hess_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op</code></a></li><li><a href="#NLPModels.hess_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.hess_op</code></a></li><li><a href="#NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op!</code></a></li><li><a href="#NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op!</code></a></li><li><a href="#NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op!</code></a></li><li><a href="#NLPModels.hess_op_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><code>NLPModels.hess_op_residual</code></a></li><li><a href="#NLPModels.hess_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><code>NLPModels.hess_op_residual!</code></a></li><li><a href="#NLPModels.hess_residual-Tuple{AbstractNLSModel, AbstractVector, AbstractVector}"><code>NLPModels.hess_residual</code></a></li><li><a href="#NLPModels.hess_structure-Tuple{AbstractNLPModel}"><code>NLPModels.hess_structure</code></a></li><li><a href="#NLPModels.hess_structure!"><code>NLPModels.hess_structure!</code></a></li><li><a href="#NLPModels.hess_structure_residual-Tuple{AbstractNLSModel}"><code>NLPModels.hess_structure_residual</code></a></li><li><a href="#NLPModels.hess_structure_residual!"><code>NLPModels.hess_structure_residual!</code></a></li><li><a href="#NLPModels.histline-Tuple{Any, Any, Any}"><code>NLPModels.histline</code></a></li><li><a href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hprod</code></a></li><li><a href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hprod</code></a></li><li><a href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.hprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.hprod!"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.hprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><code>NLPModels.hprod_residual</code></a></li><li><a href="#NLPModels.hprod_residual!"><code>NLPModels.hprod_residual!</code></a></li><li><a href="#NLPModels.increment!-Tuple{AbstractNLSModel, Symbol}"><code>NLPModels.increment!</code></a></li><li><a href="#NLPModels.increment!-Tuple{AbstractNLPModel, Symbol}"><code>NLPModels.increment!</code></a></li><li><a href="#NLPModels.inequality_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.inequality_constrained</code></a></li><li><a href="#NLPModels.jac-Tuple{AbstractNLPModel, AbstractVector}"><code>NLPModels.jac</code></a></li><li><a href="#NLPModels.jac_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_coord</code></a></li><li><a href="#NLPModels.jac_coord!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.jac_coord!</code></a></li><li><a href="#NLPModels.jac_coord_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_coord_residual</code></a></li><li><a href="#NLPModels.jac_coord_residual!"><code>NLPModels.jac_coord_residual!</code></a></li><li><a href="#NLPModels.jac_dense!"><code>NLPModels.jac_dense!</code></a></li><li><a href="#NLPModels.jac_lin-Tuple{AbstractNLPModel, AbstractVector}"><code>NLPModels.jac_lin</code></a></li><li><a href="#NLPModels.jac_lin_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_coord</code></a></li><li><a href="#NLPModels.jac_lin_coord!"><code>NLPModels.jac_lin_coord!</code></a></li><li><a href="#NLPModels.jac_lin_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_op</code></a></li><li><a href="#NLPModels.jac_lin_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_op!</code></a></li><li><a href="#NLPModels.jac_lin_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_op!</code></a></li><li><a href="#NLPModels.jac_lin_structure-Tuple{AbstractNLPModel}"><code>NLPModels.jac_lin_structure</code></a></li><li><a href="#NLPModels.jac_lin_structure!"><code>NLPModels.jac_lin_structure!</code></a></li><li><a href="#NLPModels.jac_nln-Tuple{AbstractNLPModel, AbstractVector}"><code>NLPModels.jac_nln</code></a></li><li><a href="#NLPModels.jac_nln_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_coord</code></a></li><li><a href="#NLPModels.jac_nln_coord!"><code>NLPModels.jac_nln_coord!</code></a></li><li><a href="#NLPModels.jac_nln_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_op</code></a></li><li><a href="#NLPModels.jac_nln_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_op!</code></a></li><li><a href="#NLPModels.jac_nln_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_op!</code></a></li><li><a href="#NLPModels.jac_nln_structure-Tuple{AbstractNLPModel}"><code>NLPModels.jac_nln_structure</code></a></li><li><a href="#NLPModels.jac_nln_structure!"><code>NLPModels.jac_nln_structure!</code></a></li><li><a href="#NLPModels.jac_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_op</code></a></li><li><a href="#NLPModels.jac_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op!</code></a></li><li><a href="#NLPModels.jac_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op!</code></a></li><li><a href="#NLPModels.jac_op_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_op_residual</code></a></li><li><a href="#NLPModels.jac_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op_residual!</code></a></li><li><a href="#NLPModels.jac_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op_residual!</code></a></li><li><a href="#NLPModels.jac_residual-Tuple{AbstractNLSModel, AbstractVector}"><code>NLPModels.jac_residual</code></a></li><li><a href="#NLPModels.jac_structure-Tuple{AbstractNLPModel}"><code>NLPModels.jac_structure</code></a></li><li><a href="#NLPModels.jac_structure!-Union{Tuple{T}, Tuple{AbstractNLPModel, AbstractVector{T}, AbstractVector{T}}} where T"><code>NLPModels.jac_structure!</code></a></li><li><a href="#NLPModels.jac_structure_residual-Tuple{AbstractNLSModel}"><code>NLPModels.jac_structure_residual</code></a></li><li><a href="#NLPModels.jac_structure_residual!"><code>NLPModels.jac_structure_residual!</code></a></li><li><a href="#NLPModels.jprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod</code></a></li><li><a href="#NLPModels.jprod!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod!</code></a></li><li><a href="#NLPModels.jprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod!</code></a></li><li><a href="#NLPModels.jprod_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod_lin</code></a></li><li><a href="#NLPModels.jprod_lin!"><code>NLPModels.jprod_lin!</code></a></li><li><a href="#NLPModels.jprod_lin!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod_lin!</code></a></li><li><a href="#NLPModels.jprod_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod_nln</code></a></li><li><a href="#NLPModels.jprod_nln!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod_nln!</code></a></li><li><a href="#NLPModels.jprod_nln!"><code>NLPModels.jprod_nln!</code></a></li><li><a href="#NLPModels.jprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod_residual</code></a></li><li><a href="#NLPModels.jprod_residual!-Tuple{AbstractNLSModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod_residual!</code></a></li><li><a href="#NLPModels.jprod_residual!"><code>NLPModels.jprod_residual!</code></a></li><li><a href="#NLPModels.jth_hess-Tuple{AbstractNLPModel, AbstractVector, Integer}"><code>NLPModels.jth_hess</code></a></li><li><a href="#NLPModels.jth_hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, Integer}} where {T, S}"><code>NLPModels.jth_hess_coord</code></a></li><li><a href="#NLPModels.jth_hess_coord!"><code>NLPModels.jth_hess_coord!</code></a></li><li><a href="#NLPModels.jth_hess_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><code>NLPModels.jth_hess_residual</code></a></li><li><a href="#NLPModels.jth_hess_residual_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><code>NLPModels.jth_hess_residual_coord</code></a></li><li><a href="#NLPModels.jth_hess_residual_coord!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><code>NLPModels.jth_hess_residual_coord!</code></a></li><li><a href="#NLPModels.jth_hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, Integer}} where {T, S}"><code>NLPModels.jth_hprod</code></a></li><li><a href="#NLPModels.jth_hprod!"><code>NLPModels.jth_hprod!</code></a></li><li><a href="#NLPModels.jtprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod</code></a></li><li><a href="#NLPModels.jtprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod!</code></a></li><li><a href="#NLPModels.jtprod!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod!</code></a></li><li><a href="#NLPModels.jtprod_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod_lin</code></a></li><li><a href="#NLPModels.jtprod_lin!"><code>NLPModels.jtprod_lin!</code></a></li><li><a href="#NLPModels.jtprod_lin!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod_lin!</code></a></li><li><a href="#NLPModels.jtprod_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod_nln</code></a></li><li><a href="#NLPModels.jtprod_nln!"><code>NLPModels.jtprod_nln!</code></a></li><li><a href="#NLPModels.jtprod_nln!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod_nln!</code></a></li><li><a href="#NLPModels.jtprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod_residual</code></a></li><li><a href="#NLPModels.jtprod_residual!"><code>NLPModels.jtprod_residual!</code></a></li><li><a href="#NLPModels.jtprod_residual!-Tuple{AbstractNLSModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod_residual!</code></a></li><li><a href="#NLPModels.lagscale"><code>NLPModels.lagscale</code></a></li><li><a href="#NLPModels.linearly_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.linearly_constrained</code></a></li><li><a href="#NLPModels.lines_of_description-Tuple{M} where M&lt;:AbstractNLPModelMeta"><code>NLPModels.lines_of_description</code></a></li><li><a href="#NLPModels.lines_of_description-Tuple{NLSMeta}"><code>NLPModels.lines_of_description</code></a></li><li><a href="#NLPModels.lines_of_hist-Tuple{Any, Any}"><code>NLPModels.lines_of_hist</code></a></li><li><a href="#NLPModels.neval_cons-Tuple{AbstractNLPModel}"><code>NLPModels.neval_cons</code></a></li><li><a href="#NLPModels.neval_cons_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_cons_lin</code></a></li><li><a href="#NLPModels.neval_cons_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_cons_nln</code></a></li><li><a href="#NLPModels.neval_grad-Tuple{AbstractNLPModel}"><code>NLPModels.neval_grad</code></a></li><li><a href="#NLPModels.neval_hess-Tuple{AbstractNLPModel}"><code>NLPModels.neval_hess</code></a></li><li><a href="#NLPModels.neval_hess_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_hess_residual</code></a></li><li><a href="#NLPModels.neval_hprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_hprod</code></a></li><li><a href="#NLPModels.neval_hprod_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_hprod_residual</code></a></li><li><a href="#NLPModels.neval_jac-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jac</code></a></li><li><a href="#NLPModels.neval_jac_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jac_lin</code></a></li><li><a href="#NLPModels.neval_jac_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jac_nln</code></a></li><li><a href="#NLPModels.neval_jac_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jac_residual</code></a></li><li><a href="#NLPModels.neval_jcon-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jcon</code></a></li><li><a href="#NLPModels.neval_jgrad-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jgrad</code></a></li><li><a href="#NLPModels.neval_jhess-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jhess</code></a></li><li><a href="#NLPModels.neval_jhess_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jhess_residual</code></a></li><li><a href="#NLPModels.neval_jhprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jhprod</code></a></li><li><a href="#NLPModels.neval_jprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jprod</code></a></li><li><a href="#NLPModels.neval_jprod_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jprod_lin</code></a></li><li><a href="#NLPModels.neval_jprod_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jprod_nln</code></a></li><li><a href="#NLPModels.neval_jprod_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jprod_residual</code></a></li><li><a href="#NLPModels.neval_jtprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jtprod</code></a></li><li><a href="#NLPModels.neval_jtprod_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jtprod_lin</code></a></li><li><a href="#NLPModels.neval_jtprod_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jtprod_nln</code></a></li><li><a href="#NLPModels.neval_jtprod_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jtprod_residual</code></a></li><li><a href="#NLPModels.neval_obj-Tuple{AbstractNLPModel}"><code>NLPModels.neval_obj</code></a></li><li><a href="#NLPModels.neval_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_residual</code></a></li><li><a href="#NLPModels.nls_meta-Tuple{AbstractNLSModel}"><code>NLPModels.nls_meta</code></a></li><li><a href="#NLPModels.obj-Tuple{AbstractNLSModel, AbstractVector, AbstractVector}"><code>NLPModels.obj</code></a></li><li><a href="#NLPModels.obj"><code>NLPModels.obj</code></a></li><li><a href="#NLPModels.objcons-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.objcons</code></a></li><li><a href="#NLPModels.objcons!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.objcons!</code></a></li><li><a href="#NLPModels.objcons!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.objcons!</code></a></li><li><a href="#NLPModels.objgrad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.objgrad</code></a></li><li><a href="#NLPModels.objgrad!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.objgrad!</code></a></li><li><a href="#NLPModels.objgrad!-Tuple{AbstractNLSModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.objgrad!</code></a></li><li><a href="#NLPModels.reset_data!-Tuple{AbstractNLPModel}"><code>NLPModels.reset_data!</code></a></li><li><a href="#NLPModels.residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.residual</code></a></li><li><a href="#NLPModels.residual!"><code>NLPModels.residual!</code></a></li><li><a href="#NLPModels.show_counters-Tuple{IO, Any, Any}"><code>NLPModels.show_counters</code></a></li><li><a href="#NLPModels.show_header-Tuple{IO, AbstractNLPModel}"><code>NLPModels.show_header</code></a></li><li><a href="#NLPModels.sparsityline-Tuple{Any, Any, Any}"><code>NLPModels.sparsityline</code></a></li><li><a href="#NLPModels.sum_counters-Tuple{AbstractNLPModel}"><code>NLPModels.sum_counters</code></a></li><li><a href="#NLPModels.sum_counters-Tuple{Counters}"><code>NLPModels.sum_counters</code></a></li><li><a href="#NLPModels.unconstrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.unconstrained</code></a></li><li><a href="#NLPModels.varscale"><code>NLPModels.varscale</code></a></li><li><a href="#NLPModels.@default_counters-Tuple{Any, Any}"><code>NLPModels.@default_counters</code></a></li><li><a href="#NLPModels.@default_nlscounters-Tuple{Any, Any}"><code>NLPModels.@default_nlscounters</code></a></li><li><a href="#NLPModels.@lencheck-Tuple{Any, Vararg{Any}}"><code>NLPModels.@lencheck</code></a></li><li><a href="#NLPModels.@rangecheck-Tuple{Any, Any, Vararg{Any}}"><code>NLPModels.@rangecheck</code></a></li></ul><article><details class="docstring" open="true"><summary id="NLPModels.AbstractBatchNLPModel"><a class="docstring-binding" href="#NLPModels.AbstractBatchNLPModel"><code>NLPModels.AbstractBatchNLPModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractBatchNLPModel</code></pre><p>Abstract base type for batched nonlinear optimization models.</p><p>Each model in the batch has the same number of variables and constraints, and the sparsity patterns of the Jacobian and the Hessian of the Lagrangian are identical across the batch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/batch_api.jl#L4-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.AbstractBatchNLPModelMeta"><a class="docstring-binding" href="#NLPModels.AbstractBatchNLPModelMeta"><code>NLPModels.AbstractBatchNLPModelMeta</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractBatchNLPModelMeta</code></pre><p>Abstract base type for metadata related to batched nonlinear optimization models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/batch_meta.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.AbstractNLPModel"><a class="docstring-binding" href="#NLPModels.AbstractNLPModel"><code>NLPModels.AbstractNLPModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractNLPModel</code></pre><p>Base type for an optimization model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/NLPModels.jl#L26-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.AbstractNLPModelMeta"><a class="docstring-binding" href="#NLPModels.AbstractNLPModelMeta"><code>NLPModels.AbstractNLPModelMeta</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractNLPModelMeta</code></pre><p>Base type for metadata related to an optimization model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/meta.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.AbstractNLSModel"><a class="docstring-binding" href="#NLPModels.AbstractNLSModel"><code>NLPModels.AbstractNLSModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractNLSModel &lt;: AbstractNLPModel</code></pre><p>Base type for a nonlinear least-squares model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/NLPModels.jl#L33-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.BatchNLPModelMeta"><a class="docstring-binding" href="#NLPModels.BatchNLPModelMeta"><code>NLPModels.BatchNLPModelMeta</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BatchNLPModelMeta &lt;: AbstractBatchNLPModelMeta</code></pre><p>A composite type that represents the main features of a batch of nonlinear optimization problems sharing the same structure.</p><p>Each batch contains <code>nbatch</code> independent NLP models of the form:</p><pre><code class="language-julia hljs">optimize    objᵢ(x)
subject to  lvarᵢ ≤    x     ≤ uvarᵢ
            lconᵢ ≤ consᵢ(x) ≤ uconᵢ</code></pre><p>for i = 1, ..., nbatch.</p><p>Each model variable vector <code>x</code> has dimension <code>nvar</code>, and constraint vector <code>consᵢ(x)</code> has dimension <code>ncon</code>.</p><p>All batch data are stored in matrices of size:</p><ul><li><code>(nvar, nbatch)</code> for variables and bounds (<code>x0</code>, <code>lvar</code>, <code>uvar</code>)</li><li><code>(ncon, nbatch)</code> for constraints and multipliers (<code>y0</code>, <code>lcon</code>, <code>ucon</code>)</li></ul><hr/><pre><code class="language-julia hljs">BatchNLPModelMeta(nbatch::Int, nvar::Int; kwargs...)</code></pre><p>Create a <code>BatchNLPModelMeta</code> with <code>nbatch</code> models, each having <code>nvar</code> variables. The following keyword arguments are accepted:</p><ul><li><code>x0</code>: initial guess</li><li><code>lvar</code>: matrix of lower bounds</li><li><code>uvar</code>: matrix of upper bounds</li><li><code>ncon</code>: number of general constraints</li><li><code>y0</code>: initial Lagrange multipliers</li><li><code>lcon</code>: matrix of constraint lower bounds</li><li><code>ucon</code>: matrix of constraint upper bounds</li><li><code>nnzj</code>: number of elements needed to store the nonzeros in the sparse Jacobian</li><li><code>nnzh</code>: number of elements needed to store the nonzeros in the sparse Hessian</li><li><code>minimize</code>: true if optimize == minimize</li><li><code>islp</code>: true if the problems are linear programs</li><li><code>name</code>: problem name for the batch</li><li><code>sparse_jacobian</code>: indicates whether the Jacobian of the constraints is sparse</li><li><code>sparse_hessian</code>: indicates whether the Hessian of the Lagrangian is sparse</li><li><code>grad_available</code>: indicates whether the gradient of the objective is available</li><li><code>jac_available</code>: indicates whether the Jacobian of the constraints is available</li><li><code>hess_available</code>: indicates whether the Hessian of the Lagrangian is available</li><li><code>jprod_available</code>: indicates whether the Jacobian-vector product <code>J * v</code> is available</li><li><code>jtprod_available</code>: indicates whether the transpose Jacobian-vector product <code>J&#39; * v</code> is available</li><li><code>hprod_available</code>: indicates whether the Hessian-vector product of the Lagrangian <code>H * v</code> is available</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/batch_meta.jl#L10-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.Counters"><a class="docstring-binding" href="#NLPModels.Counters"><code>NLPModels.Counters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Counters</code></pre><p>Struct for storing the number of function evaluations.</p><hr/><pre><code class="language-julia hljs">Counters()</code></pre><p>Creates an empty Counters struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.DimensionError"><a class="docstring-binding" href="#NLPModels.DimensionError"><code>NLPModels.DimensionError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DimensionError &lt;: Exception
DimensionError(name, dim_expected, dim_found)</code></pre><p>Error for unexpected dimension. Output: &quot;DimensionError: Input <code>name</code> should have length <code>dim_expected</code> not <code>dim_found</code>&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/utils.jl#L5-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.NLPModelMeta"><a class="docstring-binding" href="#NLPModels.NLPModelMeta"><code>NLPModels.NLPModelMeta</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NLPModelMeta &lt;: AbstractNLPModelMeta</code></pre><p>A composite type that represents the main features of the optimization problem</p><pre><code class="language-julia hljs">optimize    obj(x)
subject to  lvar ≤    x    ≤ uvar
            lcon ≤ cons(x) ≤ ucon</code></pre><p>where <code>x</code>        is an <code>nvar</code>-dimensional vector,       <code>obj</code>      is the real-valued objective function,       <code>cons</code>     is the vector-valued constraint function,       <code>optimize</code> is either &quot;minimize&quot; or &quot;maximize&quot;.</p><p>Here, <code>lvar</code>, <code>uvar</code>, <code>lcon</code> and <code>ucon</code> are vectors. Some of their components may be infinite to indicate that the corresponding bound or general constraint is not present.</p><hr/><pre><code class="language-julia hljs">NLPModelMeta(nvar::Integer; kwargs...)
NLPModelMeta(meta::AbstractNLPModelMeta; kwargs...)</code></pre><p>Create an <code>NLPModelMeta</code> with <code>nvar</code> variables. Alternatively, create an <code>NLPModelMeta</code> copy from another <code>AbstractNLPModelMeta</code>. The following keyword arguments are accepted:</p><ul><li><code>x0</code>: initial guess</li><li><code>lvar</code>: vector of lower bounds</li><li><code>uvar</code>: vector of upper bounds</li><li><code>nlvb</code>: number of nonlinear variables in both objectives and constraints</li><li><code>nlvo</code>: number of nonlinear variables in objectives (includes nlvb)</li><li><code>nlvc</code>: number of nonlinear variables in constraints (includes nlvb)</li><li><code>ncon</code>: number of general constraints</li><li><code>y0</code>: initial Lagrange multipliers</li><li><code>lcon</code>: vector of constraint lower bounds</li><li><code>ucon</code>: vector of constraint upper bounds</li><li><code>nnzo</code>: number of nonzeros in the gradient</li><li><code>nnzj</code>: number of elements needed to store the nonzeros in the Jacobian</li><li><code>lin_nnzj</code>: number of elements needed to store the nonzeros in the Jacobian of linear constraints</li><li><code>nln_nnzj</code>: number of elements needed to store the nonzeros in the Jacobian of nonlinear constraints</li><li><code>nnzh</code>: number of elements needed to store the nonzeros in the Hessian of the Lagrangian</li><li><code>lin</code>: indices of linear constraints</li><li><code>minimize</code>: true if optimize == minimize</li><li><code>islp</code>: true if the problem is a linear program</li><li><code>name</code>: problem name</li><li><code>variable_bounds_analysis</code>: whether to compute the partition of variables into fixed, lower-bounded, upper-bounded, range-bounded, free, and trivially infeasible sets</li><li><code>constraint_bounds_analysis</code>: whether to compute the partition of constraints into equality, lower-bounded, upper-bounded, range-bounded, free, and trivially infeasible sets</li><li><code>sparse_jacobian</code>: indicates whether the Jacobian of the constraints is sparse</li><li><code>sparse_hessian</code>: indicates whether the Hessian of the Lagrangian is sparse</li><li><code>grad_available</code>: indicates whether the gradient of the objective is available</li><li><code>jac_available</code>: indicates whether the Jacobian of the constraints is available</li><li><code>hess_available</code>: indicates whether the Hessian of the Lagrangian is available</li><li><code>jprod_available</code>: indicates whether the Jacobian-vector product <code>J * v</code> is available</li><li><code>jtprod_available</code>: indicates whether the transpose Jacobian-vector product <code>J&#39; * v</code> is available</li><li><code>hprod_available</code>: indicates whether the Hessian-vector product of the Lagrangian <code>H * v</code> is available</li></ul><p><code>NLPModelMeta</code> also contains the following attributes, which are computed from the variables above:</p><ul><li><code>nvar</code>: number of variables</li><li><code>ifix</code>: indices of fixed variables</li><li><code>ilow</code>: indices of variables with lower bound only</li><li><code>iupp</code>: indices of variables with upper bound only</li><li><code>irng</code>: indices of variables with lower and upper bound (range)</li><li><code>ifree</code>: indices of free variables</li><li><code>iinf</code>: indices of visibly infeasible bounds</li><li><code>jfix</code>: indices of equality constraints</li><li><code>jlow</code>: indices of constraints of the form c(x) ≥ cl</li><li><code>jupp</code>: indices of constraints of the form c(x) ≤ cu</li><li><code>jrng</code>: indices of constraints of the form cl ≤ c(x) ≤ cu</li><li><code>jfree</code>: indices of &quot;free&quot; constraints (there shouldn&#39;t be any)</li><li><code>jinf</code>: indices of the visibly infeasible constraints</li><li><code>nlin</code>: number of linear constraints</li><li><code>nnln</code>: number of nonlinear general constraints</li><li><code>nln</code>: indices of nonlinear constraints</li></ul><p>The attributes <code>ifix</code>, <code>ilow</code>, <code>iupp</code>, <code>irng</code>, <code>ifree</code>, and <code>iinf</code> are not computed if <code>variable_bounds_analysis</code> is set to <code>false</code>. The attributes <code>jfix</code>, <code>jlow</code>, <code>jupp</code>, <code>jrng</code>, <code>jfree</code>, and <code>jinf</code> are not computed if <code>constraint_bounds_analysis</code> is set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/meta.jl#L10-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.NLSCounters"><a class="docstring-binding" href="#NLPModels.NLSCounters"><code>NLPModels.NLSCounters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NLSCounters</code></pre><p>Struct for storing the number of functions evaluations for nonlinear least-squares models. NLSCounters also stores a <code>Counters</code> instance named <code>counters</code>.</p><hr/><pre><code class="language-julia hljs">NLSCounters()</code></pre><p>Creates an empty NLSCounters struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L3-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.NLSMeta"><a class="docstring-binding" href="#NLPModels.NLSMeta"><code>NLPModels.NLSMeta</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NLSMeta</code></pre><p>Base type for metadata related to a nonlinear least-squares model.</p><hr/><pre><code class="language-julia hljs">NLSMeta(nequ, nvar; kwargs...)</code></pre><p>Create a <code>NLSMeta</code> with <code>nequ</code> equations and <code>nvar</code> variables. The following keyword arguments are accepted:</p><ul><li><code>x0</code>: initial guess</li><li><code>nnzj</code>: number of elements needed to store the nonzeros of the Jacobian of the residual</li><li><code>nnzh</code>: number of elements needed to store the nonzeros of the sum of Hessians of the residuals</li><li><code>lin</code>: indices of linear residuals</li><li><code>jac_residual_available</code>: indicates whether the sparse Jacobian of the residuals is available</li><li><code>hess_residual_available</code>: indicates whether the sum of the sparse Hessians of the residuals is available</li><li><code>jprod_residual_available</code>: indicates whether the Jacobian-vector product for the residuals is available</li><li><code>jtprod_residual_available</code>: indicates whether the transpose Jacobian-vector product for the residuals is available</li><li><code>hprod_residual_available</code>: indicates whether the Hessian-vector product for each residual is available</li></ul><p><code>NLSMeta</code> also contains the following attributes, which are computed from the variables above:</p><ul><li><code>nequ</code>: size of the residual</li><li><code>nvar</code>: number of variables</li><li><code>nln</code>: indices of nonlinear residuals</li><li><code>nnln</code>: number of nonlinear general residuals</li><li><code>nlin</code>: number of linear residuals</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/meta.jl#L3-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.eltype-Union{Tuple{AbstractNLPModel{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><a class="docstring-binding" href="#Base.eltype-Union{Tuple{AbstractNLPModel{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eltype(nlp::AbstractNLPModel{T, S})</code></pre><p>Element type of <code>nlp.meta.x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/utils.jl#L145-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearOperators.reset!-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#LinearOperators.reset!-Tuple{AbstractNLPModel}"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(nlp)</code></pre><p>Reset evaluation count and model data (if appropriate) in <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearOperators.reset!-Tuple{Counters}"><a class="docstring-binding" href="#LinearOperators.reset!-Tuple{Counters}"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(counters)</code></pre><p>Reset evaluation counters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L97-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.bound_constrained-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.bound_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.bound_constrained</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bound_constrained(nlp)
bound_constrained(meta)</code></pre><p>Returns whether the problem has bounds on the variables and no other constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L33-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.cons!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.cons!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.cons!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c = cons!(nlp, x, c)</code></pre><p>Evaluate <span>$c(x)$</span>, the constraints at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.cons-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.cons-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.cons</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c = cons(nlp, x)</code></pre><p>Evaluate <span>$c(x)$</span>, the constraints at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.cons_lin!"><a class="docstring-binding" href="#NLPModels.cons_lin!"><code>NLPModels.cons_lin!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">c = cons_lin!(nlp, x, c)</code></pre><p>Evaluate the linear constraints at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L92-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.cons_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.cons_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.cons_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c = cons_lin(nlp, x)</code></pre><p>Evaluate the linear constraints at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L81-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.cons_nln!"><a class="docstring-binding" href="#NLPModels.cons_nln!"><code>NLPModels.cons_nln!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">c = cons_nln!(nlp, x, c)</code></pre><p>Evaluate the nonlinear constraints at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L110-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.cons_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.cons_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.cons_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c = cons_nln(nlp, x)</code></pre><p>Evaluate the nonlinear constraints at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L99-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.conscale"><a class="docstring-binding" href="#NLPModels.conscale"><code>NLPModels.conscale</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">conscale(model::AbstractNLPModel)</code></pre><p>Return a vector of constraint scaling factors for the model. These are typically used to normalize constraints to have similar magnitudes and improve  convergence behavior in nonlinear solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1436-L1442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.coo_prod!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.coo_prod!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.coo_prod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coo_prod!(rows, cols, vals, v, Av)</code></pre><p>Compute the product of a matrix <code>A</code> given by <code>(rows, cols, vals)</code> and the vector <code>v</code>. The result is stored in <code>Av</code>, which should have length equals to the number of rows of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/utils.jl#L70-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.coo_sym_prod!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.coo_sym_prod!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.coo_sym_prod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coo_sym_prod!(rows, cols, vals, v, Av)</code></pre><p>Compute the product of a symmetric matrix <code>A</code> given by <code>(rows, cols, vals)</code> and the vector <code>v</code>. The result is stored in <code>Av</code>, which should have length equals to the number of rows of <code>A</code>. Only one triangle of <code>A</code> should be passed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/utils.jl#L92-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.decrement!-Tuple{AbstractNLPModel, Symbol}"><a class="docstring-binding" href="#NLPModels.decrement!-Tuple{AbstractNLPModel, Symbol}"><code>NLPModels.decrement!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">decrement!(nlp, s)</code></pre><p>Decrement counter <code>s</code> of problem <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.equality_constrained-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.equality_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.equality_constrained</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">equality_constrained(nlp)
equality_constrained(meta)</code></pre><p>Returns whether the problem&#39;s constraints are all equalities. Unconstrained problems return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L58-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_constraint_bounds_analysis-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_constraint_bounds_analysis-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_constraint_bounds_analysis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_constraint_bounds_analysis(nlp)
get_constraint_bounds_analysis(meta)</code></pre><p>Return the value constraint<em>bounds</em>analysis from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_grad_available-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_grad_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_grad_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_grad_available(nlp)
get_grad_available(meta)</code></pre><p>Return the value grad_available from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_hess_available-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_hess_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_hess_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_hess_available(nlp)
get_hess_available(meta)</code></pre><p>Return the value hess_available from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_hess_residual_available-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_hess_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_hess_residual_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_hess_residual_available(nls)
get_hess_residual_available(nls_meta)</code></pre><p>Return the value hess<em>residual</em>available from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_hprod_available-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_hprod_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_hprod_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_hprod_available(nlp)
get_hprod_available(meta)</code></pre><p>Return the value hprod_available from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_hprod_residual_available-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_hprod_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_hprod_residual_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_hprod_residual_available(nls)
get_hprod_residual_available(nls_meta)</code></pre><p>Return the value hprod<em>residual</em>available from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_ifix-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_ifix-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ifix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ifix(nlp)
get_ifix(meta)</code></pre><p>Return the value ifix from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_ifree-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_ifree-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ifree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ifree(nlp)
get_ifree(meta)</code></pre><p>Return the value ifree from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_iinf-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_iinf-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_iinf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_iinf(nlp)
get_iinf(meta)</code></pre><p>Return the value iinf from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_ilow-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_ilow-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ilow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ilow(nlp)
get_ilow(meta)</code></pre><p>Return the value ilow from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_irng-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_irng-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_irng</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_irng(nlp)
get_irng(meta)</code></pre><p>Return the value irng from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_islp-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_islp-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_islp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_islp(nlp)
get_islp(meta)</code></pre><p>Return the value islp from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_iupp-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_iupp-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_iupp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_iupp(nlp)
get_iupp(meta)</code></pre><p>Return the value iupp from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jac_available-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jac_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jac_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jac_available(nlp)
get_jac_available(meta)</code></pre><p>Return the value jac_available from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jac_residual_available-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_jac_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_jac_residual_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jac_residual_available(nls)
get_jac_residual_available(nls_meta)</code></pre><p>Return the value jac<em>residual</em>available from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jfix-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jfix-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jfix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jfix(nlp)
get_jfix(meta)</code></pre><p>Return the value jfix from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jfree-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jfree-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jfree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jfree(nlp)
get_jfree(meta)</code></pre><p>Return the value jfree from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jinf-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jinf-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jinf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jinf(nlp)
get_jinf(meta)</code></pre><p>Return the value jinf from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jlow-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jlow-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jlow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jlow(nlp)
get_jlow(meta)</code></pre><p>Return the value jlow from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jprod_available-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jprod_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jprod_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jprod_available(nlp)
get_jprod_available(meta)</code></pre><p>Return the value jprod_available from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jprod_residual_available-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_jprod_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_jprod_residual_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jprod_residual_available(nls)
get_jprod_residual_available(nls_meta)</code></pre><p>Return the value jprod<em>residual</em>available from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jrng-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jrng-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jrng</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jrng(nlp)
get_jrng(meta)</code></pre><p>Return the value jrng from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jtprod_available-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jtprod_available-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jtprod_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jtprod_available(nlp)
get_jtprod_available(meta)</code></pre><p>Return the value jtprod_available from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jtprod_residual_available-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_jtprod_residual_available-Tuple{NLSMeta}"><code>NLPModels.get_jtprod_residual_available</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jtprod_residual_available(nls)
get_jtprod_residual_available(nls_meta)</code></pre><p>Return the value jtprod<em>residual</em>available from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_jupp-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_jupp-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_jupp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jupp(nlp)
get_jupp(meta)</code></pre><p>Return the value jupp from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_lcon-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_lcon-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lcon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lcon(nlp)
get_lcon(meta)</code></pre><p>Return the value lcon from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_lin-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_lin-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lin(nlp)
get_lin(meta)</code></pre><p>Return the value lin from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_lin-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_lin-Tuple{NLSMeta}"><code>NLPModels.get_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lin(nls)
get_lin(nls_meta)</code></pre><p>Return the value lin from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_lin_nnzj-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_lin_nnzj-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lin_nnzj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lin_nnzj(nlp)
get_lin_nnzj(meta)</code></pre><p>Return the value lin_nnzj from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_lvar-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_lvar-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_lvar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lvar(nlp)
get_lvar(meta)</code></pre><p>Return the value lvar from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_minimize-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_minimize-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_minimize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_minimize(nlp)
get_minimize(meta)</code></pre><p>Return the value minimize from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_name-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_name-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_name(nlp)
get_name(meta)</code></pre><p>Return the value name from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_ncon-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_ncon-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ncon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ncon(nlp)
get_ncon(meta)</code></pre><p>Return the value ncon from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nequ-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_nequ-Tuple{NLSMeta}"><code>NLPModels.get_nequ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nequ(nls)
get_nequ(nls_meta)</code></pre><p>Return the value nequ from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nlin-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nlin-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nlin(nlp)
get_nlin(meta)</code></pre><p>Return the value nlin from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nlin-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_nlin-Tuple{NLSMeta}"><code>NLPModels.get_nlin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nlin(nls)
get_nlin(nls_meta)</code></pre><p>Return the value nlin from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nln-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nln-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nln(nlp)
get_nln(meta)</code></pre><p>Return the value nln from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nln-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_nln-Tuple{NLSMeta}"><code>NLPModels.get_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nln(nls)
get_nln(nls_meta)</code></pre><p>Return the value nln from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nln_nnzj-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nln_nnzj-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nln_nnzj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nln_nnzj(nlp)
get_nln_nnzj(meta)</code></pre><p>Return the value nln_nnzj from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nlvb-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nlvb-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlvb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nlvb(nlp)
get_nlvb(meta)</code></pre><p>Return the value nlvb from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nlvc-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nlvc-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlvc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nlvc(nlp)
get_nlvc(meta)</code></pre><p>Return the value nlvc from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nlvo-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nlvo-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nlvo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nlvo(nlp)
get_nlvo(meta)</code></pre><p>Return the value nlvo from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nnln-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nnln-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nnln(nlp)
get_nnln(meta)</code></pre><p>Return the value nnln from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nnln-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_nnln-Tuple{NLSMeta}"><code>NLPModels.get_nnln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nnln(nls)
get_nnln(nls_meta)</code></pre><p>Return the value nnln from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nnzh-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nnzh-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnzh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nnzh(nlp)
get_nnzh(meta)</code></pre><p>Return the value nnzh from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nnzh-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_nnzh-Tuple{NLSMeta}"><code>NLPModels.get_nnzh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nnzh(nls)
get_nnzh(nls_meta)</code></pre><p>Return the value nnzh from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nnzj-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nnzj-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnzj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nnzj(nlp)
get_nnzj(meta)</code></pre><p>Return the value nnzj from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nnzj-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_nnzj-Tuple{NLSMeta}"><code>NLPModels.get_nnzj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nnzj(nls)
get_nnzj(nls_meta)</code></pre><p>Return the value nnzj from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nnzo-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nnzo-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nnzo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nnzo(nlp)
get_nnzo(meta)</code></pre><p>Return the value nnzo from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nvar-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_nvar-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_nvar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nvar(nlp)
get_nvar(meta)</code></pre><p>Return the value nvar from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_nvar-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_nvar-Tuple{NLSMeta}"><code>NLPModels.get_nvar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nvar(nls)
get_nvar(nls_meta)</code></pre><p>Return the value nvar from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_sparse_hessian-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_sparse_hessian-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_sparse_hessian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_sparse_hessian(nlp)
get_sparse_hessian(meta)</code></pre><p>Return the value sparse_hessian from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_sparse_jacobian-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_sparse_jacobian-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_sparse_jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_sparse_jacobian(nlp)
get_sparse_jacobian(meta)</code></pre><p>Return the value sparse_jacobian from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_ucon-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_ucon-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_ucon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ucon(nlp)
get_ucon(meta)</code></pre><p>Return the value ucon from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_uvar-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_uvar-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_uvar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_uvar(nlp)
get_uvar(meta)</code></pre><p>Return the value uvar from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_variable_bounds_analysis-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_variable_bounds_analysis-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_variable_bounds_analysis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_variable_bounds_analysis(nlp)
get_variable_bounds_analysis(meta)</code></pre><p>Return the value variable<em>bounds</em>analysis from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_x0-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_x0-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_x0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_x0(nlp)
get_x0(meta)</code></pre><p>Return the value x0 from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_x0-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.get_x0-Tuple{NLSMeta}"><code>NLPModels.get_x0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_x0(nls)
get_x0(nls_meta)</code></pre><p>Return the value x0 from nls_meta or nls.nls_meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/tools.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.get_y0-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.get_y0-Tuple{AbstractNLPModelMeta}"><code>NLPModels.get_y0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_y0(nlp)
get_y0(meta)</code></pre><p>Return the value y0 from meta or nlp.meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.ghjvprod!"><a class="docstring-binding" href="#NLPModels.ghjvprod!"><code>NLPModels.ghjvprod!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ghjvprod!(nlp, x, g, v, gHv)</code></pre><p>Return the vector whose i-th component is gᵀ ∇²cᵢ(x) v in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1040-L1044">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.ghjvprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.ghjvprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.ghjvprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gHv = ghjvprod(nlp, x, g, v)</code></pre><p>Return the vector whose i-th component is gᵀ ∇²cᵢ(x) v.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1024-L1028">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.grad!"><a class="docstring-binding" href="#NLPModels.grad!"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">g = grad!(nlp, x, g)</code></pre><p>Evaluate <span>$∇f(x)$</span>, the gradient of the objective function at <code>x</code> in place. This function is only available if <code>nlp.meta.grad_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L36-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.grad!-Tuple{AbstractNLSModel, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.grad!-Tuple{AbstractNLSModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">g = grad!(nls, x, g)
g = grad!(nls, x, g, Fx; recompute::Bool=true)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function of <code>nls::AbstractNLSModel</code> at <code>x</code> in place. <code>Fx</code> is overwritten with the value of the residual <code>F(x)</code>. If <code>recompute</code> is <code>true</code>, then <code>Fx</code> is updated with the residual at <code>x</code>. This function is only available if <code>nls_meta(nls).jtprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L501-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.grad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">g = grad(nlp, x)</code></pre><p>Evaluate <span>$∇f(x)$</span>, the gradient of the objective function at <code>x</code>. This function is only available if <code>nlp.meta.grad_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L24-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.has_bounds-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.has_bounds-Tuple{AbstractNLPModelMeta}"><code>NLPModels.has_bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_bounds(nlp)
has_bounds(meta)</code></pre><p>Returns whether the problem has bounds on the variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L19-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.has_equalities-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.has_equalities-Tuple{AbstractNLPModelMeta}"><code>NLPModels.has_equalities</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_equalities(nlp)</code></pre><p>Returns whether the problem has constraints and at least one of them is an equality. Unconstrained problems return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L88-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.has_inequalities-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.has_inequalities-Tuple{AbstractNLPModelMeta}"><code>NLPModels.has_inequalities</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_inequalities(nlp)</code></pre><p>Returns whether the problem has constraints and at least one of them is an inequality. Unconstrained problems return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L102-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hx = hess(nlp, x, y; obj_weight=1.0)</code></pre><p>Evaluate the Lagrangian Hessian at <code>(x,y)</code> as a sparse matrix, with objective function scaled by <code>obj_weight</code>, i.e.,</p><p class="math-container">\[∇²L(x,y) = σ ∇²f(x) + \sum_i yᵢ ∇²cᵢ(x),\]</p><p>with <code>σ = obj_weight</code> . A <code>Symmetric</code> object wrapping the lower triangle is returned. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1170-L1178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.hess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hx = hess(nlp, x; obj_weight=1.0)</code></pre><p>Evaluate the objective Hessian at <code>x</code> as a sparse matrix, with objective function scaled by <code>obj_weight</code>, i.e.,</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> . A <code>Symmetric</code> object wrapping the lower triangle is returned. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1139-L1147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_coord!"><a class="docstring-binding" href="#NLPModels.hess_coord!"><code>NLPModels.hess_coord!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vals = hess_coord!(nlp, x, y, vals; obj_weight=1.0)</code></pre><p>Evaluate the Lagrangian Hessian at <code>(x,y)</code> in sparse coordinate format, with objective function scaled by <code>obj_weight</code>, i.e.,</p><p class="math-container">\[∇²L(x,y) = σ ∇²f(x) + \sum_i yᵢ ∇²cᵢ(x),\]</p><p>with <code>σ = obj_weight</code> , overwriting <code>vals</code>. Only the lower triangle is returned. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1088-L1096">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_coord!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_coord!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = hess_coord!(nlp, x, vals; obj_weight=1.0)</code></pre><p>Evaluate the objective Hessian at <code>x</code> in sparse coordinate format, with objective function scaled by <code>obj_weight</code>, i.e.,</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> , overwriting <code>vals</code>. Only the lower triangle is returned. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1067-L1075">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = hess_coord(nlp, x, y; obj_weight=1.0)</code></pre><p>Evaluate the Lagrangian Hessian at <code>(x,y)</code> in sparse coordinate format, with objective function scaled by <code>obj_weight</code>, i.e.,</p><p class="math-container">\[∇²L(x,y) = σ ∇²f(x) + \sum_i yᵢ ∇²cᵢ(x),\]</p><p>with <code>σ = obj_weight</code> . Only the lower triangle is returned. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1118-L1126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = hess_coord(nlp, x; obj_weight=1.0)</code></pre><p>Evaluate the objective Hessian at <code>x</code> in sparse coordinate format, with objective function scaled by <code>obj_weight</code>, i.e.,</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> . Only the lower triangle is returned. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1099-L1107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_coord_residual!"><a class="docstring-binding" href="#NLPModels.hess_coord_residual!"><code>NLPModels.hess_coord_residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vals = hess_coord_residual!(nls, x, v, vals)</code></pre><p>Computes the linear combination of the Hessians of the residuals at <code>x</code> with coefficients <code>v</code> in sparse coordinate format, rewriting <code>vals</code>. This function is only available if <code>nls_meta(nls).hess_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L313-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_coord_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_coord_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_coord_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = hess_coord_residual(nls, x, v)</code></pre><p>Computes the linear combination of the Hessians of the residuals at <code>x</code> with coefficients <code>v</code> in sparse coordinate format. This function is only available if <code>nls_meta(nls).hess_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L322-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_dense!"><a class="docstring-binding" href="#NLPModels.hess_dense!"><code>NLPModels.hess_dense!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Hx = hess_dense!(nlp, x, Hx; obj_weight=1.0)
Hx = hess_dense!(nlp, x, y, Hx; obj_weight=1.0)</code></pre><p>The first method evaluates <span>$H(x)$</span>, the Hessian of the objective at <code>x</code> in dense format, overwriting <code>Hx</code>. The second method evaluates <span>$H(x,y)$</span>, the Hessian of the Lagrangian at <code>(x,y)</code> in dense format, overwriting <code>Hx</code>. Only the lower triangular part of <code>Hx</code> needs to be filled. This function is only available when <code>nlp.meta.hess_available</code> is set to <code>true</code> and <code>nlp.meta.sparse_hessian</code> is set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1159-L1167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">H = hess_op!(nlp, x, y, Hv; obj_weight=1.0)</code></pre><p>Return the Lagrangian Hessian at <code>(x,y)</code> with objective function scaled by <code>obj_weight</code> as a linear operator, and storing the result on <code>Hv</code>. The resulting object may be used as if it were a matrix, e.g., <code>w = H * v</code>. The vector <code>Hv</code> is used as preallocated storage for the operation.  The linear operator H represents</p><p class="math-container">\[∇²L(x,y) = σ ∇²f(x) + \sum_i yᵢ ∇²cᵢ(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1385-L1395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">H = hess_op!(nlp, x, Hv; obj_weight=1.0)</code></pre><p>Return the objective Hessian at <code>x</code> with objective function scaled by <code>obj_weight</code> as a linear operator, and storing the result on <code>Hv</code>. The resulting object may be used as if it were a matrix, e.g., <code>w = H * v</code>. The vector <code>Hv</code> is used as preallocated storage for the operation.  The linear operator H represents</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1323-L1333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">H = hess_op!(nlp, rows, cols, vals, Hv)</code></pre><p>Return the Hessian given by <code>(rows, cols, vals)</code> as a linear operator, and storing the result on <code>Hv</code>. The resulting object may be used as if it were a matrix, e.g., <code>w = H * v</code>. The vector <code>Hv</code> is used as preallocated storage for the operation. The linear operator H represents</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1353-L1363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hess_op</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">H = hess_op(nlp, x, y; obj_weight=1.0)</code></pre><p>Return the Lagrangian Hessian at <code>(x,y)</code> with objective function scaled by <code>obj_weight</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>H * v</code>. The linear operator H represents</p><p class="math-container">\[∇²L(x,y) = σ ∇²f(x) + \sum_i yᵢ ∇²cᵢ(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1302-L1310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.hess_op</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">H = hess_op(nlp, x; obj_weight=1.0)</code></pre><p>Return the objective Hessian at <code>x</code> with objective function scaled by <code>obj_weight</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>H * v</code>. The linear operator H represents</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1283-L1291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><code>NLPModels.hess_op_residual!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hop = hess_op_residual!(nls, x, i, Hiv)</code></pre><p>Computes the Hessian of the i-th residual at x, in linear operator form. The vector <code>Hiv</code> is used as preallocated storage for the operation. This function is only available if <code>nls_meta(nls).hprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L429-L434">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_op_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hess_op_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><code>NLPModels.hess_op_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hop = hess_op_residual(nls, x, i)</code></pre><p>Computes the Hessian of the i-th residual at x, in linear operator form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L417-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_residual-Tuple{AbstractNLSModel, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.hess_residual-Tuple{AbstractNLSModel, AbstractVector, AbstractVector}"><code>NLPModels.hess_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">H = hess_residual(nls, x, v)</code></pre><p>Computes the linear combination of the Hessians of the residuals at <code>x</code> with coefficients <code>v</code>. A <code>Symmetric</code> object wrapping the lower triangle is returned. This function is only available if <code>nls_meta(nls).hess_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L278-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_structure!"><a class="docstring-binding" href="#NLPModels.hess_structure!"><code>NLPModels.hess_structure!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hess_structure!(nlp, rows, cols)</code></pre><p>Return the structure of the Lagrangian Hessian in sparse coordinate format in place. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1059-L1064">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_structure-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.hess_structure-Tuple{AbstractNLPModel}"><code>NLPModels.hess_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols) = hess_structure(nlp)</code></pre><p>Return the structure of the Lagrangian Hessian in sparse coordinate format. This function is only available when both <code>nlp.meta.hess_available</code> and <code>nlp.meta.sparse_hessian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1047-L1052">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_structure_residual!"><a class="docstring-binding" href="#NLPModels.hess_structure_residual!"><code>NLPModels.hess_structure_residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hess_structure_residual!(nls, rows, cols)</code></pre><p>Returns the structure of the residual Hessian in place. This function is only available if <code>nls_meta(nls).hess_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L305-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hess_structure_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.hess_structure_residual-Tuple{AbstractNLSModel}"><code>NLPModels.hess_structure_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols) = hess_structure_residual(nls)</code></pre><p>Returns the structure of the residual Hessian. This function is only available if <code>nls_meta(nls).hess_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L293-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.histline-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#NLPModels.histline-Tuple{Any, Any, Any}"><code>NLPModels.histline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">histline(s, v, maxv)</code></pre><p>Return a string of the form</p><pre><code class="language-julia hljs">______NAME______: ████⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 5</code></pre><p>where:</p><ul><li><code>______NAME______</code> is <code>s</code> with padding to the left and length 16.</li><li>And the symbols █ and ⋅ fill 20 characters in the proportion of <code>v / maxv</code> to █ and the rest to ⋅.</li><li>The number <code>5</code> is v.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/show.jl#L17-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hprod!"><a class="docstring-binding" href="#NLPModels.hprod!"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Hv = hprod!(nlp, x, y, v, Hv; obj_weight=1.0)</code></pre><p>Evaluate the product of the Lagrangian Hessian at <code>(x,y)</code> with the vector <code>v</code> in place, with objective function scaled by <code>obj_weight</code>, where the Lagrangian Hessian is</p><p class="math-container">\[∇²L(x,y) = σ ∇²f(x) + \sum_i yᵢ ∇²cᵢ(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1273-L1280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.hprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hv = hprod!(nlp, rows, cols, vals, v, Hv)</code></pre><p>Evaluate the product of the objective or Lagrangian Hessian given by <code>(rows, cols, vals)</code> in triplet format with the vector <code>v</code> in place. Only one triangle of the Hessian should be given. This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1252-L1258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hv = hprod!(nlp, x, v, Hv; obj_weight=1.0)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code> in place, with objective function scaled by <code>obj_weight</code>, where the objective Hessian is</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1232-L1239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hv = hprod(nlp, x, y, v; obj_weight=1.0)</code></pre><p>Evaluate the product of the Lagrangian Hessian at <code>(x,y)</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>, where the Lagrangian Hessian is</p><p class="math-container">\[∇²L(x,y) = σ ∇²f(x) + \sum_i yᵢ ∇²cᵢ(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1211-L1218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.hprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hv = hprod(nlp, x, v; obj_weight=1.0)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>, where the objective Hessian is</p><p class="math-container">\[σ ∇²f(x),\]</p><p>with <code>σ = obj_weight</code> . This function is only available if <code>nlp.meta.hprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1192-L1199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hprod_residual!"><a class="docstring-binding" href="#NLPModels.hprod_residual!"><code>NLPModels.hprod_residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Hiv = hprod_residual!(nls, x, i, v, Hiv)</code></pre><p>Computes the product of the Hessian of the i-th residual at x, times the vector v, and stores it in vector Hiv. This function is only available if <code>nls_meta(nls).hprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L409-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.hprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.hprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><code>NLPModels.hprod_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hiv = hprod_residual(nls, x, i, v)</code></pre><p>Computes the product of the Hessian of the i-th residual at x, times the vector v. This function is only available if <code>nls_meta(nls).hprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L391-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.increment!-Tuple{AbstractNLPModel, Symbol}"><a class="docstring-binding" href="#NLPModels.increment!-Tuple{AbstractNLPModel, Symbol}"><code>NLPModels.increment!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">increment!(nlp, s)</code></pre><p>Increment counter <code>s</code> of problem <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L54-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.increment!-Tuple{AbstractNLSModel, Symbol}"><a class="docstring-binding" href="#NLPModels.increment!-Tuple{AbstractNLSModel, Symbol}"><code>NLPModels.increment!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">increment!(nls, s)</code></pre><p>Increment counter <code>s</code> of problem <code>nls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L76-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.inequality_constrained-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.inequality_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.inequality_constrained</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inequality_constrained(nlp)
inequality_constrained(meta)</code></pre><p>Returns whether the problem&#39;s constraints are all inequalities. Unconstrained problems return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L73-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac-Tuple{AbstractNLPModel, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jac-Tuple{AbstractNLPModel, AbstractVector}"><code>NLPModels.jac</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac(nlp, x)</code></pre><p>Evaluate <span>$J(x)$</span>, the constraints Jacobian at <code>x</code> as a sparse matrix. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L316-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_coord!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jac_coord!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.jac_coord!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = jac_coord!(nlp, x, vals)</code></pre><p>Evaluate <span>$J(x)$</span>, the constraints Jacobian at <code>x</code> in sparse coordinate format, overwriting <code>vals</code>. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L267-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_coord</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = jac_coord(nlp, x)</code></pre><p>Evaluate <span>$J(x)$</span>, the constraints Jacobian at <code>x</code> in sparse coordinate format. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L296-L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_coord_residual!"><a class="docstring-binding" href="#NLPModels.jac_coord_residual!"><code>NLPModels.jac_coord_residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vals = jac_coord_residual!(nls, x, vals)</code></pre><p>Computes the Jacobian of the residual at <code>x</code> in sparse coordinate format, rewriting <code>vals</code>. <code>rows</code> and <code>cols</code> are not rewritten. This function is only available if <code>nls_meta(nls).jac_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L60-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_coord_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_coord_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_coord_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols,vals) = jac_coord_residual(nls, x)</code></pre><p>Computes the Jacobian of the residual at <code>x</code> in sparse coordinate format. This function is only available if <code>nls_meta(nls).jac_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L69-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_dense!"><a class="docstring-binding" href="#NLPModels.jac_dense!"><code>NLPModels.jac_dense!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac_dense!(nlp, x, Jx)</code></pre><p>Evaluate <span>$J(x)$</span>, the constraints Jacobian at <code>x</code> in dense format, overwriting <code>Jx</code>. This function is only available when <code>nlp.meta.jac_available</code> is set to <code>true</code> and <code>nlp.meta.sparse_jacobian</code> is set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L308-L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin-Tuple{AbstractNLPModel, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jac_lin-Tuple{AbstractNLPModel, AbstractVector}"><code>NLPModels.jac_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac_lin(nlp, x)</code></pre><p>Evaluate <span>$J(x)$</span>, the linear constraints Jacobian at <code>x</code> as a sparse matrix. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L349-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin_coord!"><a class="docstring-binding" href="#NLPModels.jac_lin_coord!"><code>NLPModels.jac_lin_coord!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vals = jac_lin_coord!(nlp, x, vals)</code></pre><p>Evaluate <span>$J(x)$</span>, the linear constraints Jacobian at <code>x</code> in sparse coordinate format, overwriting <code>vals</code>. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L329-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_lin_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_coord</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = jac_lin_coord(nlp, x)</code></pre><p>Evaluate <span>$J(x)$</span>, the linear constraints Jacobian at <code>x</code> in sparse coordinate format. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L337-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_lin_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_lin_op!(nlp, rows, cols, vals, Jv, Jtv)</code></pre><p>Return the linear Jacobian given by <code>(rows, cols, vals)</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. The values <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L829-L836">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_lin_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_lin_op!(nlp, x, Jv, Jtv)</code></pre><p>Return the linear Jacobian at <code>x</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. The values <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L792-L799">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_lin_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_lin_op</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_lin_op(nlp, x)</code></pre><p>Return the linear Jacobian at <code>x</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L778-L784">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin_structure!"><a class="docstring-binding" href="#NLPModels.jac_lin_structure!"><code>NLPModels.jac_lin_structure!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jac_lin_structure!(nlp, rows, cols)</code></pre><p>Return the structure of the linear constraints Jacobian in sparse coordinate format in place. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L239-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_lin_structure-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.jac_lin_structure-Tuple{AbstractNLPModel}"><code>NLPModels.jac_lin_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols) = jac_lin_structure(nlp)</code></pre><p>Return the structure of the linear constraints Jacobian in sparse coordinate format. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L227-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln-Tuple{AbstractNLPModel, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jac_nln-Tuple{AbstractNLPModel, AbstractVector}"><code>NLPModels.jac_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac_nln(nlp, x)</code></pre><p>Evaluate <span>$J(x)$</span>, the nonlinear constraints Jacobian at <code>x</code> as a sparse matrix. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L382-L387">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln_coord!"><a class="docstring-binding" href="#NLPModels.jac_nln_coord!"><code>NLPModels.jac_nln_coord!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vals = jac_nln_coord!(nlp, x, vals)</code></pre><p>Evaluate <span>$J(x)$</span>, the nonlinear constraints Jacobian at <code>x</code> in sparse coordinate format, overwriting <code>vals</code>. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L362-L367">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_nln_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_coord</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = jac_nln_coord(nlp, x)</code></pre><p>Evaluate <span>$J(x)$</span>, the nonlinear constraints Jacobian at <code>x</code> in sparse coordinate format. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L370-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_nln_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_nln_op!(nlp, rows, cols, vals, Jv, Jtv)</code></pre><p>Return the nonlinear Jacobian given by <code>(rows, cols, vals)</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. The values <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L920-L927">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_nln_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_nln_op!(nlp, x, Jv, Jtv)</code></pre><p>Return the nonlinear Jacobian at <code>x</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. The values <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L883-L890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_nln_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_nln_op</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_nln_op(nlp, x)</code></pre><p>Return the nonlinear Jacobian at <code>x</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L869-L875">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln_structure!"><a class="docstring-binding" href="#NLPModels.jac_nln_structure!"><code>NLPModels.jac_nln_structure!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jac_nln_structure!(nlp, rows, cols)</code></pre><p>Return the structure of the nonlinear constraints Jacobian in sparse coordinate format in place. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L259-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_nln_structure-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.jac_nln_structure-Tuple{AbstractNLPModel}"><code>NLPModels.jac_nln_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols) = jac_nln_structure(nlp)</code></pre><p>Return the structure of the nonlinear constraints Jacobian in sparse coordinate format. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L247-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_op!(nlp, rows, cols, vals, Jv, Jtv)</code></pre><p>Return the Jacobian given by <code>(rows, cols, vals)</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. The values <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L738-L745">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_op!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector{T}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_op!(nlp, x, Jv, Jtv)</code></pre><p>Return the Jacobian at <code>x</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or <code>J&#39; * v</code>. The values <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L701-L708">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_op-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_op</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">J = jac_op(nlp, x)</code></pre><p>Return the Jacobian at <code>x</code> as a linear operator. The resulting object may be used as if it were a matrix, e.g., <code>J * v</code> or  <code>J&#39; * v</code>. This function is only available if both <code>nlp.meta.jprod_available</code> and <code>nlp.meta.jtprod_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L687-L693">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op_residual!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac_op_residual!(nls, x, Jv, Jtv)</code></pre><p>Computes <span>$J(x)$</span>, the Jacobian of the residual at x, in linear operator form. The vectors <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nls_meta(nls).jprod_residual_available</code> and <code>nls_meta(nls).jtprod_residual_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L187-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_op_residual!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jac_op_residual!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac_op_residual!(nls, rows, cols, vals, Jv, Jtv)</code></pre><p>Computes <span>$J(x)$</span>, the Jacobian of the residual given by <code>(rows, cols, vals)</code>, in linear operator form. The vectors <code>Jv</code> and <code>Jtv</code> are used as preallocated storage for the operations. This function is only available if both <code>nls_meta(nls).jprod_residual_available</code> and <code>nls_meta(nls).jtprod_residual_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L231-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_op_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jac_op_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.jac_op_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac_op_residual(nls, x)</code></pre><p>Computes <span>$J(x)$</span>, the Jacobian of the residual at x, in linear operator form. This function is only available if both <code>nls_meta(nls).jprod_residual_available</code> and <code>nls_meta(nls).jtprod_residual_available</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L174-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_residual-Tuple{AbstractNLSModel, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jac_residual-Tuple{AbstractNLSModel, AbstractVector}"><code>NLPModels.jac_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jx = jac_residual(nls, x)</code></pre><p>Computes <span>$J(x)$</span>, the Jacobian of the residual at x. This function is only available if <code>nls_meta(nls).jac_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L27-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_structure!-Union{Tuple{T}, Tuple{AbstractNLPModel, AbstractVector{T}, AbstractVector{T}}} where T"><a class="docstring-binding" href="#NLPModels.jac_structure!-Union{Tuple{T}, Tuple{AbstractNLPModel, AbstractVector{T}, AbstractVector{T}}} where T"><code>NLPModels.jac_structure!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jac_structure!(nlp, rows, cols)</code></pre><p>Return the structure of the constraints Jacobian in sparse coordinate format in place. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L190-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_structure-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.jac_structure-Tuple{AbstractNLPModel}"><code>NLPModels.jac_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols) = jac_structure(nlp)</code></pre><p>Return the structure of the constraints Jacobian in sparse coordinate format. This function is only available when both <code>nlp.meta.jac_available</code> and <code>nlp.meta.sparse_jacobian</code> are set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L178-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_structure_residual!"><a class="docstring-binding" href="#NLPModels.jac_structure_residual!"><code>NLPModels.jac_structure_residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols) = jac_structure_residual!(nls, rows, cols)</code></pre><p>Returns the structure of the constraint&#39;s Jacobian in sparse coordinate format in place. This function is only available if <code>nls_meta(nls).jac_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L40-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jac_structure_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.jac_structure_residual-Tuple{AbstractNLSModel}"><code>NLPModels.jac_structure_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(rows,cols) = jac_structure_residual(nls)</code></pre><p>Returns the structure of the constraint&#39;s Jacobian in sparse coordinate format. This function is only available if <code>nls_meta(nls).jac_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L48-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jprod!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod!(nlp, x, v, Jv)</code></pre><p>Evaluate <span>$J(x)v$</span>, the Jacobian-vector product at <code>x</code> in place. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L407-L412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod!(nlp, rows, cols, vals, v, Jv)</code></pre><p>Evaluate <span>$J(x)v$</span>, the Jacobian-vector product, where the Jacobian is given by <code>(rows, cols, vals)</code> in triplet format. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L434-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod(nlp, x, v)</code></pre><p>Evaluate <span>$J(x)v$</span>, the Jacobian-vector product at <code>x</code>. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L395-L400">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_lin!"><a class="docstring-binding" href="#NLPModels.jprod_lin!"><code>NLPModels.jprod_lin!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_lin!(nlp, x, v, Jv)</code></pre><p>Evaluate <span>$J(x)v$</span>, the linear Jacobian-vector product at <code>x</code> in place. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L467-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_lin!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jprod_lin!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod_lin!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_lin!(nlp, rows, cols, vals, v, Jv)</code></pre><p>Evaluate <span>$J(x)v$</span>, the linear Jacobian-vector product, where the Jacobian is given by <code>(rows, cols, vals)</code> in triplet format. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L475-L480">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jprod_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_lin(nlp, x, v)</code></pre><p>Evaluate <span>$J(x)v$</span>, the linear Jacobian-vector product at <code>x</code>. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L455-L460">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_nln!"><a class="docstring-binding" href="#NLPModels.jprod_nln!"><code>NLPModels.jprod_nln!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_nln!(nlp, x, v, Jv)</code></pre><p>Evaluate <span>$J(x)v$</span>, the nonlinear Jacobian-vector product at <code>x</code> in place. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L508-L513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_nln!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jprod_nln!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod_nln!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_nln!(nlp, rows, cols, vals, v, Jv)</code></pre><p>Evaluate <span>$J(x)v$</span>, the nonlinear Jacobian-vector product, where the Jacobian is given by <code>(rows, cols, vals)</code> in triplet format. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L516-L521">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jprod_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_nln(nlp, x, v)</code></pre><p>Evaluate <span>$J(x)v$</span>, the nonlinear Jacobian-vector product at <code>x</code>. This function is only available if <code>nlp.meta.jprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L496-L501">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_residual!"><a class="docstring-binding" href="#NLPModels.jprod_residual!"><code>NLPModels.jprod_residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_residual!(nls, x, v, Jv)</code></pre><p>Computes the product of the Jacobian of the residual at x and a vector, i.e., <span>$J(x)v$</span>, storing it in <code>Jv</code>. This function is only available if <code>nls_meta(nls).jprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L97-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_residual!-Tuple{AbstractNLSModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jprod_residual!-Tuple{AbstractNLSModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jprod_residual!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_residual!(nls, rows, cols, vals, v, Jv)</code></pre><p>Computes the product of the Jacobian of the residual given by <code>(rows, cols, vals)</code> and a vector, i.e., <span>$J(x)v$</span>, storing it in <code>Jv</code>. This function is only available if <code>nls_meta(nls).jprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L105-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jprod_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jv = jprod_residual(nls, x, v)</code></pre><p>Computes the product of the Jacobian of the residual at x and a vector, i.e.,  <span>$J(x)v$</span>. This function is only available if <code>nls_meta(nls).jprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L81-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hess-Tuple{AbstractNLPModel, AbstractVector, Integer}"><a class="docstring-binding" href="#NLPModels.jth_hess-Tuple{AbstractNLPModel, AbstractVector, Integer}"><code>NLPModels.jth_hess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hx = jth_hess(nlp, x, j)</code></pre><p>Evaluate the Hessian of j-th constraint at <code>x</code> as a sparse matrix with the same sparsity pattern as the Lagrangian Hessian. A <code>Symmetric</code> object wrapping the lower triangle is returned. This function is only available when <code>nlp.meta.sparse_hessian</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L983-L990">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hess_coord!"><a class="docstring-binding" href="#NLPModels.jth_hess_coord!"><code>NLPModels.jth_hess_coord!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vals = jth_hess_coord!(nlp, x, j, vals)</code></pre><p>Evaluate the Hessian of j-th constraint at <code>x</code> in sparse coordinate format, with <code>vals</code> of length <code>nlp.meta.nnzh</code>, in place. Only the lower triangle is returned. This function is only available when <code>nlp.meta.sparse_hessian</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L974-L980">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, Integer}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jth_hess_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, Integer}} where {T, S}"><code>NLPModels.jth_hess_coord</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = jth_hess_coord(nlp, x, j)</code></pre><p>Evaluate the Hessian of j-th constraint at <code>x</code> in sparse coordinate format. Only the lower triangle is returned. This function is only available when <code>nlp.meta.sparse_hessian</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L960-L966">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hess_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jth_hess_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><code>NLPModels.jth_hess_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hj = jth_hess_residual(nls, x, j)</code></pre><p>Computes the Hessian of the j-th residual at x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L340-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hess_residual_coord!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jth_hess_residual_coord!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64, AbstractVector}} where {T, S}"><code>NLPModels.jth_hess_residual_coord!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = jth_hess_residual_coord!(nls, x, j, vals)</code></pre><p>Evaluate the Hessian of j-th residual at <code>x</code> in sparse coordinate format, with <code>vals</code> of length <code>nls.nls_meta.nnzh</code>, in place. Only the lower triangle is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L370-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hess_residual_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jth_hess_residual_coord-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, Int64}} where {T, S}"><code>NLPModels.jth_hess_residual_coord</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vals = jth_hess_residual_coord(nls, x, j)</code></pre><p>Evaluate the Hessian of j-th residual at <code>x</code> in sparse coordinate format. Only the lower triangle is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L353-L358">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hprod!"><a class="docstring-binding" href="#NLPModels.jth_hprod!"><code>NLPModels.jth_hprod!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Hv = jth_hprod!(nlp, x, v, j, Hv)</code></pre><p>Evaluate the product of the Hessian of j-th constraint at <code>x</code> with the vector <code>v</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1016-L1021">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jth_hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, Integer}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jth_hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector, Integer}} where {T, S}"><code>NLPModels.jth_hprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hv = jth_hprod(nlp, x, v, j)</code></pre><p>Evaluate the product of the Hessian of j-th constraint at <code>x</code> with the vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L999-L1003">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jtprod!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod!(nlp, x, v, Jtv)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the transposed-Jacobian-vector product at <code>x</code> in place. If the problem has linear and nonlinear constraints, this function allocates. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L550-L556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jtprod!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod!(nlp, rows, cols, vals, v, Jtv)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the transposed-Jacobian-vector product, where the Jacobian is given by <code>(rows, cols, vals)</code> in triplet format. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L579-L585">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jtprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod(nlp, x, v)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the transposed-Jacobian-vector product at <code>x</code>. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L537-L542">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_lin!"><a class="docstring-binding" href="#NLPModels.jtprod_lin!"><code>NLPModels.jtprod_lin!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_lin!(nlp, x, v, Jtv)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the linear transposed-Jacobian-vector product at <code>x</code> in place. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L614-L619">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_lin!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jtprod_lin!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod_lin!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_lin!(nlp, rows, cols, vals, v, Jtv)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the linear transposed-Jacobian-vector product, where the Jacobian is given by <code>(rows, cols, vals)</code> in triplet format. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L622-L628">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jtprod_lin-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_lin(nlp, x, v)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the linear transposed-Jacobian-vector product at <code>x</code>. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L601-L606">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_nln!"><a class="docstring-binding" href="#NLPModels.jtprod_nln!"><code>NLPModels.jtprod_nln!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_nln!(nlp, x, v, Jtv)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the nonlinear transposed-Jacobian-vector product at <code>x</code> in place. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L657-L662">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_nln!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jtprod_nln!-Tuple{AbstractNLPModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod_nln!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_nln!(nlp, rows, cols, vals, v, Jtv)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the nonlinear transposed-Jacobian-vector product, where the Jacobian is given by <code>(rows, cols, vals)</code> in triplet format. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L665-L671">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jtprod_nln-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_nln(nlp, x, v)</code></pre><p>Evaluate <span>$J(x)^Tv$</span>, the nonlinear transposed-Jacobian-vector product at <code>x</code>. This function is only available if <code>nlp.meta.jtprod_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L644-L649">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_residual!"><a class="docstring-binding" href="#NLPModels.jtprod_residual!"><code>NLPModels.jtprod_residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_residual!(nls, x, v, Jtv)</code></pre><p>Computes the product of the transpose of the Jacobian of the residual at x and a vector, i.e., <span>$J(x)^Tv$</span>, storing it in <code>Jtv</code>. This function is only available if <code>nls_meta(nls).jtprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L144-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_residual!-Tuple{AbstractNLSModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.jtprod_residual!-Tuple{AbstractNLSModel, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.jtprod_residual!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_residual!(nls, rows, cols, vals, v, Jtv)</code></pre><p>Computes the product of the transpose of the Jacobian of the residual given by <code>(rows, cols, vals)</code> and a vector, i.e., <span>$J(x)^Tv$</span>, storing it in <code>Jv</code>. This function is only available if <code>nls_meta(nls).jtprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L152-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.jtprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.jtprod_residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.jtprod_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Jtv = jtprod_residual(nls, x, v)</code></pre><p>Computes the product of the transpose of the Jacobian of the residual at x and a vector, i.e., <span>$J(x)^Tv$</span>. This function is only available if <code>nls_meta(nls).jtprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L127-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.lagscale"><a class="docstring-binding" href="#NLPModels.lagscale"><code>NLPModels.lagscale</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lagscale(model::AbstractNLPModel)</code></pre><p>Return a vector of scaling factors for the Lagrange multipliers associated with constraints. This can be used to improve numerical stability or condition number when solving KKT systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1428-L1433">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.linearly_constrained-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.linearly_constrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.linearly_constrained</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linearly_constrained(nlp)
linearly_constrained(meta)</code></pre><p>Returns whether the problem&#39;s constraints are known to be all linear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L49-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.lines_of_description-Tuple{M} where M&lt;:AbstractNLPModelMeta"><a class="docstring-binding" href="#NLPModels.lines_of_description-Tuple{M} where M&lt;:AbstractNLPModelMeta"><code>NLPModels.lines_of_description</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lines_of_description(meta)</code></pre><p>Describe <code>meta</code> for the <code>show</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/show.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.lines_of_description-Tuple{NLSMeta}"><a class="docstring-binding" href="#NLPModels.lines_of_description-Tuple{NLSMeta}"><code>NLPModels.lines_of_description</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lines_of_description(nls_meta)</code></pre><p>Describe <code>nls_meta</code> for the <code>show</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/show.jl#L7-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.lines_of_hist-Tuple{Any, Any}"><a class="docstring-binding" href="#NLPModels.lines_of_hist-Tuple{Any, Any}"><code>NLPModels.lines_of_hist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lines_of_hist(S, V)</code></pre><p>Return a vector of <code>histline(s, v, maxv)</code>s using pairs of <code>s</code> in <code>S</code> and <code>v</code> in <code>V</code>. <code>maxv</code> is given by the maximum of <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/show.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_cons-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_cons-Tuple{AbstractNLPModel}"><code>NLPModels.neval_cons</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_cons(nlp)</code></pre><p>Get the number of <code>cons</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_cons_lin-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_cons_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_cons_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_cons_lin(nlp)</code></pre><p>Get the number of <code>cons</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_cons_nln-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_cons_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_cons_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_cons_nln(nlp)</code></pre><p>Get the number of <code>cons</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_grad-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_grad-Tuple{AbstractNLPModel}"><code>NLPModels.neval_grad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_grad(nlp)</code></pre><p>Get the number of <code>grad</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_hess-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_hess-Tuple{AbstractNLPModel}"><code>NLPModels.neval_hess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_hess(nlp)</code></pre><p>Get the number of <code>hess</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_hess_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.neval_hess_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_hess_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_hess_residual(nlp)</code></pre><p>Get the number of <code>hess</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_hprod-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_hprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_hprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_hprod(nlp)</code></pre><p>Get the number of <code>hprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_hprod_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.neval_hprod_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_hprod_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_hprod_residual(nlp)</code></pre><p>Get the number of <code>hprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jac-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jac-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jac</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jac(nlp)</code></pre><p>Get the number of <code>jac</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jac_lin-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jac_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jac_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jac_lin(nlp)</code></pre><p>Get the number of <code>jac</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jac_nln-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jac_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jac_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jac_nln(nlp)</code></pre><p>Get the number of <code>jac</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jac_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.neval_jac_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jac_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jac_residual(nlp)</code></pre><p>Get the number of <code>jac</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jcon-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jcon-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jcon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jcon(nlp)</code></pre><p>Get the number of <code>jcon</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jgrad-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jgrad-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jgrad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jgrad(nlp)</code></pre><p>Get the number of <code>jgrad</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jhess-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jhess-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jhess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jhess(nlp)</code></pre><p>Get the number of <code>jhess</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jhess_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.neval_jhess_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jhess_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jhess_residual(nlp)</code></pre><p>Get the number of <code>jhess</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jhprod-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jhprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jhprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jhprod(nlp)</code></pre><p>Get the number of <code>jhprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jprod-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jprod(nlp)</code></pre><p>Get the number of <code>jprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jprod_lin-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jprod_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jprod_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jprod_lin(nlp)</code></pre><p>Get the number of <code>jprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jprod_nln-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jprod_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jprod_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jprod_nln(nlp)</code></pre><p>Get the number of <code>jprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jprod_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.neval_jprod_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jprod_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jprod_residual(nlp)</code></pre><p>Get the number of <code>jprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jtprod-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jtprod-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jtprod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jtprod(nlp)</code></pre><p>Get the number of <code>jtprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jtprod_lin-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jtprod_lin-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jtprod_lin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jtprod_lin(nlp)</code></pre><p>Get the number of <code>jtprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jtprod_nln-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_jtprod_nln-Tuple{AbstractNLPModel}"><code>NLPModels.neval_jtprod_nln</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jtprod_nln(nlp)</code></pre><p>Get the number of <code>jtprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_jtprod_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.neval_jtprod_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_jtprod_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_jtprod_residual(nlp)</code></pre><p>Get the number of <code>jtprod</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_obj-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.neval_obj-Tuple{AbstractNLPModel}"><code>NLPModels.neval_obj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_obj(nlp)</code></pre><p>Get the number of <code>obj</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.neval_residual-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.neval_residual-Tuple{AbstractNLSModel}"><code>NLPModels.neval_residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neval_residual(nlp)</code></pre><p>Get the number of <code>residual</code> evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/counters.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.nls_meta-Tuple{AbstractNLSModel}"><a class="docstring-binding" href="#NLPModels.nls_meta-Tuple{AbstractNLSModel}"><code>NLPModels.nls_meta</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nls_meta(nls)</code></pre><p>Returns the <code>nls_meta</code> structure of <code>nls</code>. Use this instead of <code>nls.nls_meta</code> to handle models that have internal models.</p><p>For basic models <code>nls_meta(nls)</code> is defined as <code>nls.nls_meta</code>, but composite models might not keep <code>nls_meta</code> themselves, so they might specialize it to something like <code>nls.internal.nls_meta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/meta.jl#L91-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.obj"><a class="docstring-binding" href="#NLPModels.obj"><code>NLPModels.obj</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">f = obj(nlp, x)</code></pre><p>Evaluate <span>$f(x)$</span>, the objective function of <code>nlp</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L17-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.obj-Tuple{AbstractNLSModel, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.obj-Tuple{AbstractNLSModel, AbstractVector, AbstractVector}"><code>NLPModels.obj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f = obj(nls, x)
f = obj(nls, x, Fx; recompute::Bool=true)</code></pre><p>Evaluate <code>f(x)</code>, the objective function of <code>nls::AbstractNLSModel</code>. <code>Fx</code> is overwritten with the value of the residual <code>F(x)</code>. If <code>recompute</code> is <code>true</code>, then <code>Fx</code> is updated with the residual at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L455-L461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.objcons!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.objcons!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.objcons!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f, c = objcons!(nlp, x, c)</code></pre><p>Evaluate <span>$f(x)$</span> and <span>$c(x)$</span> at <code>x</code>. <code>c</code> is overwritten with the value of <span>$c(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L140-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.objcons!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.objcons!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector, AbstractVector}} where {T, S}"><code>NLPModels.objcons!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f, c = objcons!(nls, x, c)
f, c = objcons!(nls, x, c, Fx; recompute::Bool=true)</code></pre><p>In-place evaluation of constraints and objective for AbstractNLSModel. <code>Fx</code> is overwritten with the value of the residual <code>F(x)</code>. If <code>recompute</code> is <code>true</code>, then <code>Fx</code> is updated with the residual at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L475-L482">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.objcons-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.objcons-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.objcons</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f, c = objcons(nlp, x)</code></pre><p>Evaluate <span>$f(x)$</span> and <span>$c(x)$</span> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L129-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.objgrad!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.objgrad!-Tuple{AbstractNLPModel, AbstractVector, AbstractVector}"><code>NLPModels.objgrad!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f, g = objgrad!(nlp, x, g)</code></pre><p>Evaluate <span>$f(x)$</span> and <span>$∇f(x)$</span> at <code>x</code>. <code>g</code> is overwritten with the value of <span>$∇f(x)$</span>. This function is only available if <code>nlp.meta.grad_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L165-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.objgrad!-Tuple{AbstractNLSModel, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#NLPModels.objgrad!-Tuple{AbstractNLSModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.objgrad!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f, g = objgrad!(nls, x, g)
f, g = objgrad!(nls, x, g, Fx; recompute::Bool=true)</code></pre><p>Evaluate f(x) and ∇f(x) of <code>nls::AbstractNLSModel</code> at <code>x</code>. <code>Fx</code> is overwritten with the value of the residual <code>F(x)</code>. If <code>recompute</code> is <code>true</code>, then <code>Fx</code> is updated with the residual at <code>x</code>. This function is only available if <code>nls_meta(nls).jtprod_residual_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L529-L536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.objgrad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.objgrad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLPModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.objgrad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">f, g = objgrad(nlp, x)</code></pre><p>Evaluate <span>$f(x)$</span> and <span>$∇f(x)$</span> at <code>x</code>. This function is only available if <code>nlp.meta.grad_available</code> is set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L153-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.reset_data!-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.reset_data!-Tuple{AbstractNLPModel}"><code>NLPModels.reset_data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset_data!(nlp)</code></pre><p>Reset model data if appropriate. This method should be overloaded if a subtype of <code>AbstractNLPModel</code> contains data that should be reset, such as a quasi-Newton linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/meta.jl#L341-L348">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.residual!"><a class="docstring-binding" href="#NLPModels.residual!"><code>NLPModels.residual!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Fx = residual!(nls, x, Fx)</code></pre><p>Computes <span>$F(x)$</span>, the residual at x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L20-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><a class="docstring-binding" href="#NLPModels.residual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractNLSModel{T, S}, AbstractVector}} where {T, S}"><code>NLPModels.residual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Fx = residual(nls, x)</code></pre><p>Computes <span>$F(x)$</span>, the residual at x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/api.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.show_counters-Tuple{IO, Any, Any}"><a class="docstring-binding" href="#NLPModels.show_counters-Tuple{IO, Any, Any}"><code>NLPModels.show_counters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">show_counters(io, counters, fields)</code></pre><p>Show the <code>fields</code> of the struct <code>counters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/show.jl#L125-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.show_header-Tuple{IO, AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.show_header-Tuple{IO, AbstractNLPModel}"><code>NLPModels.show_header</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">show_header(io, nlp)</code></pre><p>Show a header for the specific <code>nlp</code> type. Should be imported and defined for every model implementing the NLPModels API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/show.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.sparsityline-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#NLPModels.sparsityline-Tuple{Any, Any, Any}"><code>NLPModels.sparsityline</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparsityline(s, v, maxv)</code></pre><p>Return a string of the form</p><pre><code class="language-julia hljs">______NAME______: ( 80.00% sparsity)   5</code></pre><p>where:</p><ul><li><code>______NAME______</code> is <code>s</code> with padding to the left and length 16.</li><li>The sparsity value is given by <code>v / maxv</code>.</li><li>The number <code>5</code> is v.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/show.jl#L35-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.sum_counters-Tuple{AbstractNLPModel}"><a class="docstring-binding" href="#NLPModels.sum_counters-Tuple{AbstractNLPModel}"><code>NLPModels.sum_counters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sum_counters(nlp)</code></pre><p>Sum all counters of problem <code>nlp</code> except <code>cons</code>, <code>jac</code>, <code>jprod</code> and <code>jtprod</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L90-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.sum_counters-Tuple{Counters}"><a class="docstring-binding" href="#NLPModels.sum_counters-Tuple{Counters}"><code>NLPModels.sum_counters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sum_counters(counters)</code></pre><p>Sum all counters of <code>counters</code> except <code>cons</code>, <code>jac</code>, <code>jprod</code> and <code>jtprod</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/counters.jl#L76-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.unconstrained-Tuple{AbstractNLPModelMeta}"><a class="docstring-binding" href="#NLPModels.unconstrained-Tuple{AbstractNLPModelMeta}"><code>NLPModels.unconstrained</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unconstrained(nlp)
unconstrained(meta)</code></pre><p>Returns whether the problem in unconstrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/tools.jl#L41-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.varscale"><a class="docstring-binding" href="#NLPModels.varscale"><code>NLPModels.varscale</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varscale(model::AbstractNLPModel)</code></pre><p>Return a vector containing the scaling factors for each variable in the model. This is typically used to normalize variables for numerical stability in solvers.</p><p>By default, the scaling is model-dependent. If not overridden by the model, a vector of ones  is returned. Inspired by the AMPL scaling conventions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/api.jl#L1417-L1425">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.@default_counters-Tuple{Any, Any}"><a class="docstring-binding" href="#NLPModels.@default_counters-Tuple{Any, Any}"><code>NLPModels.@default_counters</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@default_counters Model inner</code></pre><p>Define functions relating counters of <code>Model</code> to counters of <code>Model.inner</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/utils.jl#L118-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.@default_nlscounters-Tuple{Any, Any}"><a class="docstring-binding" href="#NLPModels.@default_nlscounters-Tuple{Any, Any}"><code>NLPModels.@default_nlscounters</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@default_nlscounters Model inner</code></pre><p>Define functions relating NLS counters of <code>Model</code> to NLS counters of <code>Model.inner</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nls/utils.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.@lencheck-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#NLPModels.@lencheck-Tuple{Any, Vararg{Any}}"><code>NLPModels.@lencheck</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@lencheck n x y z …</code></pre><p>Check that arrays <code>x</code>, <code>y</code>, <code>z</code>, etc. have a prescribed length <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/utils.jl#L26-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NLPModels.@rangecheck-Tuple{Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#NLPModels.@rangecheck-Tuple{Any, Any, Vararg{Any}}"><code>NLPModels.@rangecheck</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rangecheck ℓ u i j k …</code></pre><p>Check that values <code>i</code>, <code>j</code>, <code>k</code>, etc. are in the range <code>[ℓ,u]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/15f3da25dedf5dee25c76c6469898f88cbb2a83c/src/nlp/utils.jl#L44-L48">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« Internals</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 04:53">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
